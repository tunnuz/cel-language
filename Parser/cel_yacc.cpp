#define YY_parse_h_included
/*#define YY_USE_CLASS 
*/
/*  A Bison++ parser, made from cel.ypp  */

 /* with Bison++ version bison++ Version 1.21.9-1, adapted from GNU bison by coetmeur@icdc.fr
Maintained by Magnus Ekdahl <magnus@debian.org>
  */

#define yyparse yyparse
#define yylex yylex
#define yyerror yyerror
#define yylval yylval
#define yychar yychar
#define yydebug yydebug

#line 1 "/usr/share/bison++/bison.cc"
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  

   As a special exception, when this file is copied by Bison++ into a
   Bison++ output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison, and has been in Bison++ since 1.21.9.  

*/

/* HEADER SECTION */
#if defined( _MSDOS ) || defined(MSDOS) || defined(__MSDOS__) 
 #define __MSDOS_AND_ALIKE
#endif

#if defined(_WINDOWS) && defined(_MSC_VER)
 #define __HAVE_NO_ALLOCA
 #define __MSDOS_AND_ALIKE
#endif

#ifndef alloca
 #if defined( __GNUC__)
  #define alloca __builtin_alloca

 #elif (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc)  || defined (__sgi)
  #include <alloca.h>

 #elif defined (__MSDOS_AND_ALIKE)
  #include <malloc.h>
  #ifndef __TURBOC__
   /* MS C runtime lib */
   #define alloca _alloca
  #endif

 #elif defined(_AIX)
  /* pragma must be put before any C/C++ instruction !! */
  #pragma alloca
  #include <malloc.h>

 #elif defined(__hpux)
  #ifdef __cplusplus
   extern "C" {
     void *alloca (unsigned int);
   };
  #else /* not __cplusplus */
   void *alloca ();
  #endif /* not __cplusplus */

 #endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
#endif /* alloca not defined.  */

#ifdef c_plusplus
 #ifndef __cplusplus
  #define __cplusplus
 #endif
#endif

#ifdef __cplusplus
 #ifndef YY_USE_CLASS
/*#warning "For C++ its recomended to use bison++, otherwise classes won't be generated"*/
 #endif
#else
 #ifndef __STDC__
  #define const
 #endif
 #ifdef YY_USE_CLASS
  #error "This is a C++ header generated by bison++, please use a C++ compiler!"
 #endif
#endif

#include <stdio.h>
#define YYBISON 1  

 #line 88 "/usr/share/bison++/bison.cc"
#line 2 "cel.ypp"


/*
--------------------------------------------------------------------------------
This source file is part of CEL (Camera Evaluation Language), a research project
by Marc Christie (INRIA-Rennes, France), Roberto Ranon and Tommaso Urli (both
from HCI-Lab, University of Udine, Italy).

For the latest info, see http://www.cameracontrol.org/language

Copyright (c) 2010 INRIA Rennes, France and University of Udine, Italy
Also see acknowledgements in Readme.txt

If you use, modify, or simply find this code interesting please let us know
at info@cameracontrol.org.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA 02111-1307, USA, or go to
http://www.gnu.org/copyleft/lesser.txt.
--------------------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include "celparser.h"


using namespace std;

extern int yylineno;
int yyerror(char *str);
int yyparse(void);
int yylex();
int yyterminate();

CEL::SymbolTable savedSymbols;
CEL::SymbolTable localSymbols;


#line 53 "cel.ypp"
typedef union {
	int intType;
	double doubleType;
	char * stringType;
	CEL::Expression *expressionType;
	CEL::BaseType *baseType;	
	CEL::CallFunctionOperator *callFunctionType;
	CEL::Operator *operatorType;
	CEL::ComparisonOperator *cmpOperatorType;
	CEL::ConditionalOperator *cndOperatorType;
	CEL::MathOperator *mathOperatorType;
	CEL::Symbol *symbolType;
	CEL::CelParser *parserType;	
	CEL::HashTable *hashTableType;
	CEL::PixelSetExpression *pixelSetExpressionType;
	CEL::VectorOfTargets *vectorOfTargetsType;
	CEL::TargetExpression *targetExpressionType;
	CEL::Target *targetType;
	std::vector<CEL::Expression *> *vectorExpressionType;
} yy_parse_stype;
#define YY_parse_STYPE yy_parse_stype
#ifndef YY_USE_CLASS
#define YYSTYPE yy_parse_stype
#endif

#line 88 "/usr/share/bison++/bison.cc"
/* %{ and %header{ and %union, during decl */
#define YY_parse_BISON 1

#ifndef YY_parse_COMPATIBILITY
 #ifndef YY_USE_CLASS
  #define  YY_parse_COMPATIBILITY 1
 #else
  #define  YY_parse_COMPATIBILITY 0
 #endif
#endif

#if YY_parse_COMPATIBILITY != 0
 /* backward compatibility */
 #ifdef YYLTYPE
  #ifndef YY_parse_LTYPE
   #define YY_parse_LTYPE YYLTYPE
  #endif
 #endif
/* Testing alternative bison solution
   /#ifdef YYSTYPE*/
#ifndef YY_parse_STYPE 
   #define YY_parse_STYPE YYSTYPE
#endif
/*#endif*/
 #ifdef YYDEBUG
  #ifndef YY_parse_DEBUG
   #define  YY_parse_DEBUG YYDEBUG
  #endif
 #endif
 
 /* use goto to be compatible */
 #ifndef YY_parse_USE_GOTO
  #define YY_parse_USE_GOTO 1
 #endif
#endif

/* use no goto to be clean in C++ */
#ifndef YY_parse_USE_GOTO
 #define YY_parse_USE_GOTO 0
#endif

#ifndef YY_parse_PURE

 #line 130 "/usr/share/bison++/bison.cc"

#line 130 "/usr/share/bison++/bison.cc"
/*  YY_parse_PURE */
#endif

/* section apres lecture def, avant lecture grammaire S2 */

 #line 134 "/usr/share/bison++/bison.cc"
#define YY_parse_PARSE yyparse
#define YY_parse_LEX yylex
#define YY_parse_ERROR yyerror
#define YY_parse_LVAL yylval
#define YY_parse_CHAR yychar
#define YY_parse_DEBUG yydebug

#line 134 "/usr/share/bison++/bison.cc"
/* prefix */
#ifndef YY_parse_DEBUG

 #line 136 "/usr/share/bison++/bison.cc"

#line 136 "/usr/share/bison++/bison.cc"
/* YY_parse_DEBUG */
#endif


#ifndef YY_parse_LSP_NEEDED

 #line 141 "/usr/share/bison++/bison.cc"

#line 141 "/usr/share/bison++/bison.cc"
 /* YY_parse_LSP_NEEDED*/
#endif



/* DEFAULT LTYPE*/
#ifdef YY_parse_LSP_NEEDED
#ifndef YY_parse_LTYPE
#ifndef BISON_YYLTYPE_ISDECLARED
#define BISON_YYLTYPE_ISDECLARED
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#endif
#define YY_parse_LTYPE yyltype
#endif
#endif
/* DEFAULT STYPE*/
      /* We used to use `unsigned long' as YY_parse_STYPE on MSDOS,
	 but it seems better to be consistent.
	 Most programs should declare their own type anyway.  */

#ifndef YY_parse_STYPE
#define YY_parse_STYPE int
#endif
/* DEFAULT MISCELANEOUS */
#ifndef YY_parse_PARSE
#define YY_parse_PARSE yyparse
#endif
#ifndef YY_parse_LEX
#define YY_parse_LEX yylex
#endif
#ifndef YY_parse_LVAL
#define YY_parse_LVAL yylval
#endif
#ifndef YY_parse_LLOC
#define YY_parse_LLOC yylloc
#endif
#ifndef YY_parse_CHAR
#define YY_parse_CHAR yychar
#endif
#ifndef YY_parse_NERRS
#define YY_parse_NERRS yynerrs
#endif
#ifndef YY_parse_DEBUG_FLAG
#define YY_parse_DEBUG_FLAG yydebug
#endif
#ifndef YY_parse_ERROR
#define YY_parse_ERROR yyerror
#endif

#ifndef YY_parse_PARSE_PARAM
 #ifndef YY_USE_CLASS
  #ifdef YYPARSE_PARAM
   #define YY_parse_PARSE_PARAM void* YYPARSE_PARAM 
  #else
   #ifndef __STDC__
    #ifndef __cplusplus
     #define YY_parse_PARSE_PARAM
    #endif
   #endif
  #endif
 #endif
 #ifndef YY_parse_PARSE_PARAM
  #define YY_parse_PARSE_PARAM void
 #endif
#endif

#if YY_parse_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YY_parse_LTYPE
#ifndef YYLTYPE
#define YYLTYPE YY_parse_LTYPE
#else
/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header */
#endif
#endif

/* Removed due to bison compabilityproblems
/#ifndef YYSTYPE
/#define YYSTYPE YY_parse_STYPE
/#else*/
/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header */
/*#endif*/

#ifdef YY_parse_PURE
#  ifndef YYPURE
#    define YYPURE YY_parse_PURE
#  endif
#endif

#ifdef YY_parse_DEBUG
#  ifndef YYDEBUG
#    define YYDEBUG YY_parse_DEBUG 
#  endif
#endif

#ifndef YY_parse_ERROR_VERBOSE
 #ifdef YYERROR_VERBOSE
  #define YY_parse_ERROR_VERBOSE YYERROR_VERBOSE
 #endif
#endif

#ifndef YY_parse_LSP_NEEDED
#  ifdef YYLSP_NEEDED
#    define YY_parse_LSP_NEEDED YYLSP_NEEDED
#  endif
#endif

#endif

#ifndef YY_USE_CLASS
/* TOKEN C */

 #line 263 "/usr/share/bison++/bison.cc"
#define	SQRT	258
#define	SQR	259
#define	SIN	260
#define	COS	261
#define	TAN	262
#define	ASIN	263
#define	ACOS	264
#define	ATAN	265
#define	ATAN2	266
#define	EXP	267
#define	IF	268
#define	ELSE	269
#define	COUNT	270
#define	COVEREDBY	271
#define	LEFTOF	272
#define	RIGHTOF	273
#define	ABOVEOF	274
#define	BELOWOF	275
#define	RENDER	276
#define	CUBERENDER	277
#define	DECLARE	278
#define	EVALUATE	279
#define	CEL_INCLUDE	280
#define	CELEOF	281
#define	SILHOUETTE	282
#define	MAXX	283
#define	MINX	284
#define	MAXY	285
#define	MINY	286
#define	DISTANCE	287
#define	OVERLAP	288
#define	IMAGEWIDTH	289
#define	IMAGEHEIGHT	290
#define	RECT	291
#define	VIEWVOLUME	292
#define	FILENAME	293
#define	FUNCTION	294
#define	CMP	295
#define	DOUBLE	296
#define	UDOUBLE	297
#define	OP2_PREC_1	298
#define	OP2_PREC_2	299
#define	UMINUS	300


#line 263 "/usr/share/bison++/bison.cc"
 /* #defines tokens */
#else
/* CLASS */
#ifndef YY_parse_CLASS
#define YY_parse_CLASS parse
#endif
#ifndef YY_parse_INHERIT
#define YY_parse_INHERIT
#endif
#ifndef YY_parse_MEMBERS
#define YY_parse_MEMBERS 
#endif
#ifndef YY_parse_LEX_BODY
#define YY_parse_LEX_BODY  
#endif
#ifndef YY_parse_ERROR_BODY
#define YY_parse_ERROR_BODY  
#endif
#ifndef YY_parse_CONSTRUCTOR_PARAM
#define YY_parse_CONSTRUCTOR_PARAM
#endif
#ifndef YY_parse_CONSTRUCTOR_CODE
#define YY_parse_CONSTRUCTOR_CODE
#endif
#ifndef YY_parse_CONSTRUCTOR_INIT
#define YY_parse_CONSTRUCTOR_INIT
#endif
/* choose between enum and const */
#ifndef YY_parse_USE_CONST_TOKEN
#define YY_parse_USE_CONST_TOKEN 0
/* yes enum is more compatible with flex,  */
/* so by default we use it */ 
#endif
#if YY_parse_USE_CONST_TOKEN != 0
#ifndef YY_parse_ENUM_TOKEN
#define YY_parse_ENUM_TOKEN yy_parse_enum_token
#endif
#endif

class YY_parse_CLASS YY_parse_INHERIT
{
public: 
#if YY_parse_USE_CONST_TOKEN != 0
/* static const int token ... */

 #line 307 "/usr/share/bison++/bison.cc"
static const int SQRT;
static const int SQR;
static const int SIN;
static const int COS;
static const int TAN;
static const int ASIN;
static const int ACOS;
static const int ATAN;
static const int ATAN2;
static const int EXP;
static const int IF;
static const int ELSE;
static const int COUNT;
static const int COVEREDBY;
static const int LEFTOF;
static const int RIGHTOF;
static const int ABOVEOF;
static const int BELOWOF;
static const int RENDER;
static const int CUBERENDER;
static const int DECLARE;
static const int EVALUATE;
static const int CEL_INCLUDE;
static const int CELEOF;
static const int SILHOUETTE;
static const int MAXX;
static const int MINX;
static const int MAXY;
static const int MINY;
static const int DISTANCE;
static const int OVERLAP;
static const int IMAGEWIDTH;
static const int IMAGEHEIGHT;
static const int RECT;
static const int VIEWVOLUME;
static const int FILENAME;
static const int FUNCTION;
static const int CMP;
static const int DOUBLE;
static const int UDOUBLE;
static const int OP2_PREC_1;
static const int OP2_PREC_2;
static const int UMINUS;


#line 307 "/usr/share/bison++/bison.cc"
 /* decl const */
#else
enum YY_parse_ENUM_TOKEN { YY_parse_NULL_TOKEN=0

 #line 310 "/usr/share/bison++/bison.cc"
	,SQRT=258
	,SQR=259
	,SIN=260
	,COS=261
	,TAN=262
	,ASIN=263
	,ACOS=264
	,ATAN=265
	,ATAN2=266
	,EXP=267
	,IF=268
	,ELSE=269
	,COUNT=270
	,COVEREDBY=271
	,LEFTOF=272
	,RIGHTOF=273
	,ABOVEOF=274
	,BELOWOF=275
	,RENDER=276
	,CUBERENDER=277
	,DECLARE=278
	,EVALUATE=279
	,CEL_INCLUDE=280
	,CELEOF=281
	,SILHOUETTE=282
	,MAXX=283
	,MINX=284
	,MAXY=285
	,MINY=286
	,DISTANCE=287
	,OVERLAP=288
	,IMAGEWIDTH=289
	,IMAGEHEIGHT=290
	,RECT=291
	,VIEWVOLUME=292
	,FILENAME=293
	,FUNCTION=294
	,CMP=295
	,DOUBLE=296
	,UDOUBLE=297
	,OP2_PREC_1=298
	,OP2_PREC_2=299
	,UMINUS=300


#line 310 "/usr/share/bison++/bison.cc"
 /* enum token */
     }; /* end of enum declaration */
#endif
public:
 int YY_parse_PARSE (YY_parse_PARSE_PARAM);
 virtual void YY_parse_ERROR(char *msg) YY_parse_ERROR_BODY;
#ifdef YY_parse_PURE
#ifdef YY_parse_LSP_NEEDED
 virtual int  YY_parse_LEX (YY_parse_STYPE *YY_parse_LVAL,YY_parse_LTYPE *YY_parse_LLOC) YY_parse_LEX_BODY;
#else
 virtual int  YY_parse_LEX (YY_parse_STYPE *YY_parse_LVAL) YY_parse_LEX_BODY;
#endif
#else
 virtual int YY_parse_LEX() YY_parse_LEX_BODY;
 YY_parse_STYPE YY_parse_LVAL;
#ifdef YY_parse_LSP_NEEDED
 YY_parse_LTYPE YY_parse_LLOC;
#endif
 int   YY_parse_NERRS;
 int    YY_parse_CHAR;
#endif
#if YY_parse_DEBUG != 0
 int YY_parse_DEBUG_FLAG;   /*  nonzero means print parse trace     */
#endif
public:
 YY_parse_CLASS(YY_parse_CONSTRUCTOR_PARAM);
public:
 YY_parse_MEMBERS 
};
/* other declare folow */
#if YY_parse_USE_CONST_TOKEN != 0

 #line 341 "/usr/share/bison++/bison.cc"
const int YY_parse_CLASS::SQRT=258;
const int YY_parse_CLASS::SQR=259;
const int YY_parse_CLASS::SIN=260;
const int YY_parse_CLASS::COS=261;
const int YY_parse_CLASS::TAN=262;
const int YY_parse_CLASS::ASIN=263;
const int YY_parse_CLASS::ACOS=264;
const int YY_parse_CLASS::ATAN=265;
const int YY_parse_CLASS::ATAN2=266;
const int YY_parse_CLASS::EXP=267;
const int YY_parse_CLASS::IF=268;
const int YY_parse_CLASS::ELSE=269;
const int YY_parse_CLASS::COUNT=270;
const int YY_parse_CLASS::COVEREDBY=271;
const int YY_parse_CLASS::LEFTOF=272;
const int YY_parse_CLASS::RIGHTOF=273;
const int YY_parse_CLASS::ABOVEOF=274;
const int YY_parse_CLASS::BELOWOF=275;
const int YY_parse_CLASS::RENDER=276;
const int YY_parse_CLASS::CUBERENDER=277;
const int YY_parse_CLASS::DECLARE=278;
const int YY_parse_CLASS::EVALUATE=279;
const int YY_parse_CLASS::CEL_INCLUDE=280;
const int YY_parse_CLASS::CELEOF=281;
const int YY_parse_CLASS::SILHOUETTE=282;
const int YY_parse_CLASS::MAXX=283;
const int YY_parse_CLASS::MINX=284;
const int YY_parse_CLASS::MAXY=285;
const int YY_parse_CLASS::MINY=286;
const int YY_parse_CLASS::DISTANCE=287;
const int YY_parse_CLASS::OVERLAP=288;
const int YY_parse_CLASS::IMAGEWIDTH=289;
const int YY_parse_CLASS::IMAGEHEIGHT=290;
const int YY_parse_CLASS::RECT=291;
const int YY_parse_CLASS::VIEWVOLUME=292;
const int YY_parse_CLASS::FILENAME=293;
const int YY_parse_CLASS::FUNCTION=294;
const int YY_parse_CLASS::CMP=295;
const int YY_parse_CLASS::DOUBLE=296;
const int YY_parse_CLASS::UDOUBLE=297;
const int YY_parse_CLASS::OP2_PREC_1=298;
const int YY_parse_CLASS::OP2_PREC_2=299;
const int YY_parse_CLASS::UMINUS=300;


#line 341 "/usr/share/bison++/bison.cc"
 /* const YY_parse_CLASS::token */
#endif
/*apres const  */
YY_parse_CLASS::YY_parse_CLASS(YY_parse_CONSTRUCTOR_PARAM) YY_parse_CONSTRUCTOR_INIT
{
#if YY_parse_DEBUG != 0
YY_parse_DEBUG_FLAG=0;
#endif
YY_parse_CONSTRUCTOR_CODE;
};
#endif

 #line 352 "/usr/share/bison++/bison.cc"


#define	YYFINAL		232
#define	YYFLAG		-32768
#define	YYNTBASE	60

#define YYTRANSLATE(x) ((unsigned)(x) <= 300 ? yytranslate[x] : 86)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    46,    52,     2,     2,     2,     2,     2,    55,
    56,    43,    42,    57,    41,     2,    44,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    54,     2,
    53,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    58,     2,    59,    45,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    47,    48,    49,    50,    51
};

#if YY_parse_DEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     8,     9,    12,    16,    21,    23,    24,    27,
    32,    34,    39,    41,    45,    47,    49,    51,    54,    57,
    59,    63,    68,    73,    78,    83,    88,    93,    98,   103,
   110,   115,   120,   125,   130,   135,   140,   147,   158,   160,
   163,   167,   171,   175,   179,   183,   185,   187,   189,   191,
   199,   203,   208,   213,   218,   225,   232,   239,   246,   253,
   260,   262,   265,   267,   271,   275,   286,   288,   290,   292,
   296,   298,   300,   305,   307,   309,   313,   314,   317
};

static const short yyrhs[] = {    61,
     0,    62,    23,    66,    24,    84,     0,     0,    62,    63,
     0,    64,    61,    65,     0,    25,    52,    38,    52,     0,
    26,     0,     0,    66,    67,     0,    68,    53,    71,    54,
     0,    39,     0,    39,    55,    69,    56,     0,    70,     0,
    69,    57,    70,     0,    39,     0,    73,     0,    47,     0,
    41,    47,     0,    42,    47,     0,    72,     0,    55,    73,
    56,     0,     3,    55,    73,    56,     0,     4,    55,    73,
    56,     0,     5,    55,    73,    56,     0,     6,    55,    73,
    56,     0,     7,    55,    73,    56,     0,     8,    55,    73,
    56,     0,     9,    55,    73,    56,     0,    10,    55,    73,
    56,     0,    11,    55,    73,    57,    73,    56,     0,    12,
    55,    73,    56,     0,    15,    55,    75,    56,     0,    28,
    55,    75,    56,     0,    29,    55,    75,    56,     0,    30,
    55,    75,    56,     0,    31,    55,    75,    56,     0,    32,
    55,    75,    57,    75,    56,     0,    36,    55,    47,    57,
    47,    57,    47,    57,    47,    56,     0,    37,     0,    41,
    73,     0,    73,    41,    73,     0,    73,    42,    73,     0,
    73,    43,    73,     0,    73,    44,    73,     0,    73,    45,
    73,     0,    34,     0,    35,     0,    76,     0,    81,     0,
    13,    55,    74,    56,    73,    14,    73,     0,    73,    40,
    73,     0,    22,    55,    76,    56,     0,    21,    55,    76,
    56,     0,    27,    55,    75,    56,     0,    16,    55,    75,
    57,    75,    56,     0,    17,    55,    75,    57,    75,    56,
     0,    18,    55,    75,    57,    75,    56,     0,    19,    55,
    75,    57,    75,    56,     0,    20,    55,    75,    57,    75,
    56,     0,    33,    55,    75,    57,    75,    56,     0,    78,
     0,    46,    77,     0,    78,     0,    58,    79,    59,     0,
    52,    80,    52,     0,    36,    55,    72,    57,    72,    57,
    72,    57,    72,    56,     0,    37,     0,    81,     0,    78,
     0,    79,    57,    78,     0,    39,     0,    82,     0,    82,
    55,    83,    56,     0,    39,     0,    73,     0,    83,    57,
    73,     0,     0,    84,    85,     0,    73,    54,     0
};

#endif

#if (YY_parse_DEBUG != 0) || defined(YY_parse_ERROR_VERBOSE) 
static const short yyrline[] = { 0,
   110,   112,   119,   120,   125,   130,   142,   161,   162,   164,
   190,   197,   216,   227,   241,   248,   254,   256,   258,   262,
   267,   273,   280,   287,   294,   301,   308,   315,   322,   330,
   339,   347,   353,   359,   366,   372,   378,   384,   390,   397,
   405,   413,   421,   429,   437,   445,   452,   459,   465,   476,
   486,   504,   511,   517,   522,   528,   534,   540,   546,   552,
   559,   564,   569,   574,   580,   586,   591,   597,   603,   610,
   617,   619,   625,   654,   670,   676,   684,   687,   692
};

static const char * const yytname[] = {   "$","error","$illegal.","SQRT","SQR",
"SIN","COS","TAN","ASIN","ACOS","ATAN","ATAN2","EXP","IF","ELSE","COUNT","COVEREDBY",
"LEFTOF","RIGHTOF","ABOVEOF","BELOWOF","RENDER","CUBERENDER","DECLARE","EVALUATE",
"CEL_INCLUDE","CELEOF","SILHOUETTE","MAXX","MINX","MAXY","MINY","DISTANCE","OVERLAP",
"IMAGEWIDTH","IMAGEHEIGHT","RECT","VIEWVOLUME","FILENAME","FUNCTION","CMP","'-'",
"'+'","'*'","'/'","'^'","'!'","DOUBLE","UDOUBLE","OP2_PREC_1","OP2_PREC_2","UMINUS",
"'\"'","'='","';'","'('","')'","','","'['","']'","structure","corpus","list_of_includes",
"include_declaration","include","eof","list_of_declarations","declaration","leftBodyRelation",
"list_of_leftArguments","leftArgument","rightBodyRelation","realValue","expression",
"condition","pixelSetExpression","TargetExpression","Targets","target","ListOfTargets",
"targetName","functionCall","functionName","list_of_rightArguments","list_of_evaluators",
"evaluator",""
};
#endif

static const short yyr1[] = {     0,
    60,    61,    62,    62,    63,    64,    65,    66,    66,    67,
    68,    68,    69,    69,    70,    71,    72,    72,    72,    73,
    73,    73,    73,    73,    73,    73,    73,    73,    73,    73,
    73,    73,    73,    73,    73,    73,    73,    73,    73,    73,
    73,    73,    73,    73,    73,    73,    73,    73,    73,    73,
    74,    75,    75,    75,    75,    75,    75,    75,    75,    75,
    76,    76,    77,    77,    78,    78,    78,    78,    79,    79,
    80,    81,    81,    82,    83,    83,    84,    84,    85
};

static const short yyr2[] = {     0,
     1,     5,     0,     2,     3,     4,     1,     0,     2,     4,
     1,     4,     1,     3,     1,     1,     1,     2,     2,     1,
     3,     4,     4,     4,     4,     4,     4,     4,     4,     6,
     4,     4,     4,     4,     4,     4,     6,    10,     1,     2,
     3,     3,     3,     3,     3,     1,     1,     1,     1,     7,
     3,     4,     4,     4,     6,     6,     6,     6,     6,     6,
     1,     2,     1,     3,     3,    10,     1,     1,     1,     3,
     1,     1,     4,     1,     1,     3,     0,     2,     2
};

static const short yydefact[] = {     3,
     1,     0,     8,     0,     4,     3,     0,     0,     0,    77,
    11,     9,     0,     0,     7,     5,     2,     0,     0,     6,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,    46,    47,     0,
    39,    74,     0,     0,     0,    17,     0,     0,    20,     0,
    48,    61,    49,    72,    78,    15,     0,    13,     0,    16,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,    17,    40,
    19,     0,    67,     0,    62,    63,    68,    71,     0,     0,
     0,     0,     0,     0,     0,    79,     0,    12,     0,    10,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,    69,     0,    65,    21,    41,    42,    43,    44,    45,
    75,     0,    14,    22,    23,    24,    25,    26,    27,    28,
    29,     0,    31,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    32,    33,    34,    35,    36,     0,
    18,     0,     0,     0,    64,    73,     0,     0,    51,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,    70,    76,    30,     0,     0,     0,     0,     0,
     0,    53,    52,    54,     0,    37,     0,     0,    50,     0,
     0,     0,     0,     0,     0,     0,     0,    55,    56,    57,
    58,    59,    60,     0,     0,     0,     0,    38,    66,     0,
     0,     0
};

static const short yydefgoto[] = {   230,
     1,     2,     5,     6,    16,     7,    12,    13,    57,    58,
    59,    49,    50,   112,   122,    51,    85,    52,   133,    89,
    53,    54,   142,    17,    55
};

static const short yypact[] = {-32768,
-32768,   -12,-32768,   -37,-32768,-32768,   -16,    -8,    37,-32768,
   -33,-32768,    17,   -26,-32768,-32768,   156,    45,   156,-32768,
    35,    36,    40,    52,    53,    54,    55,    65,    66,    67,
    68,    85,    86,    87,    89,    90,    91,-32768,-32768,    92,
-32768,-32768,   209,   102,   -27,-32768,    93,   156,-32768,    71,
-32768,-32768,-32768,   115,-32768,-32768,    10,-32768,   103,   131,
   156,   156,   156,   156,   156,   156,   156,   156,   156,   156,
   156,    84,    84,    84,    84,    84,    84,   -14,-32768,-32768,
-32768,   123,-32768,    25,-32768,-32768,-32768,-32768,   137,    38,
   156,   156,   156,   156,   156,-32768,   156,-32768,    45,-32768,
   138,   186,   191,   224,   229,   234,   250,   255,   -25,   260,
   111,    83,   141,   144,   145,   146,   149,   150,   151,   152,
   154,   167,   169,   170,   193,   196,   153,   206,   197,   200,
    77,-32768,     0,-32768,-32768,    -4,    -4,   213,   213,-32768,
   131,    12,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   156,-32768,   156,   156,    84,    84,    84,    84,    84,
    19,    19,    84,    84,-32768,-32768,-32768,-32768,-32768,    84,
-32768,   212,    77,    25,-32768,-32768,   156,   276,   131,    -7,
   203,   205,   225,   226,   227,   207,   230,   231,   232,   251,
   252,   253,-32768,   131,-32768,   156,    84,    84,    84,    84,
    84,-32768,-32768,-32768,    84,-32768,   241,    77,   131,   256,
   257,   258,   259,   266,   267,   268,   269,-32768,-32768,-32768,
-32768,-32768,-32768,   261,    77,   271,   272,-32768,-32768,   281,
   324,-32768
};

static const short yypgoto[] = {-32768,
   323,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   235,
-32768,   -77,   -19,-32768,   -71,   -64,-32768,   -31,-32768,-32768,
   -24,-32768,-32768,-32768,-32768
};


#define	YYLAST		334


static const short yytable[] = {    60,
   130,   123,   124,   125,   126,   127,   196,    10,    82,    83,
     3,    42,     4,    86,     8,    91,    92,    93,    94,    95,
    87,    18,    11,    80,    47,    20,   128,    44,    90,    14,
    84,   152,   129,    91,    92,    93,    94,    95,    93,    94,
    95,   101,   102,   103,   104,   105,   106,   107,   108,   109,
   110,   111,   132,   130,    82,    83,   174,    42,   175,    87,
    82,    83,    15,    42,    45,    98,    99,   176,   177,    19,
    47,   136,   137,   138,   139,   140,    47,   141,    91,    92,
    93,    94,    95,    56,   181,   182,   183,   184,   185,    61,
    62,   188,   189,   135,    63,   192,   186,   187,   190,   113,
   114,   115,   116,   117,   118,   119,    64,    65,    66,    67,
   120,    91,    92,    93,    94,    95,   121,   128,    44,    68,
    69,    70,    71,    46,    96,   210,   211,   212,   213,   214,
   217,    88,   178,   215,   179,   180,    87,    87,   155,    72,
    73,    74,   193,    75,    76,    77,    78,   227,    81,    87,
   154,    91,    92,    93,    94,    95,   100,   194,    21,    22,
    23,    24,    25,    26,    27,    28,    29,    30,    31,    97,
    32,    91,    92,    93,    94,    95,   209,   131,    91,    92,
    93,    94,    95,    33,    34,    35,    36,    37,   134,    38,
    39,    40,    41,   144,    42,   156,    43,    44,   157,   158,
   159,    45,    46,   160,   161,   162,   163,    47,   164,   170,
    48,    21,    22,    23,    24,    25,    26,    27,    28,    29,
    30,    31,   165,    32,   166,   167,    91,    92,    93,    94,
    95,    91,    92,    93,    94,    95,    33,    34,    35,    36,
    37,   145,    38,    39,    40,    41,   146,    42,   168,    43,
    44,   169,   171,   172,    45,    79,   173,    95,   191,   197,
    47,   198,   202,    48,    91,    92,    93,    94,    95,    91,
    92,    93,    94,    95,    91,    92,    93,    94,    95,   147,
   231,   199,   200,   201,   148,   203,   204,   216,   205,   149,
    91,    92,    93,    94,    95,    91,    92,    93,    94,    95,
    91,    92,    93,    94,    95,   150,   206,   226,   207,   208,
   151,   218,   219,   220,   221,   153,    91,    92,    93,    94,
    95,   222,   223,   232,   224,   225,   228,   229,     9,     0,
     0,   195,     0,   143
};

static const short yycheck[] = {    19,
    78,    73,    74,    75,    76,    77,    14,    24,    36,    37,
    23,    39,    25,    45,    52,    41,    42,    43,    44,    45,
    45,    55,    39,    43,    52,    52,    41,    42,    48,    38,
    58,    57,    47,    41,    42,    43,    44,    45,    43,    44,
    45,    61,    62,    63,    64,    65,    66,    67,    68,    69,
    70,    71,    84,   131,    36,    37,    57,    39,    59,    84,
    36,    37,    26,    39,    46,    56,    57,    56,    57,    53,
    52,    91,    92,    93,    94,    95,    52,    97,    41,    42,
    43,    44,    45,    39,   156,   157,   158,   159,   160,    55,
    55,   163,   164,    56,    55,   173,   161,   162,   170,    16,
    17,    18,    19,    20,    21,    22,    55,    55,    55,    55,
    27,    41,    42,    43,    44,    45,    33,    41,    42,    55,
    55,    55,    55,    47,    54,   197,   198,   199,   200,   201,
   208,    39,   152,   205,   154,   155,   161,   162,    56,    55,
    55,    55,   174,    55,    55,    55,    55,   225,    47,   174,
    40,    41,    42,    43,    44,    45,    54,   177,     3,     4,
     5,     6,     7,     8,     9,    10,    11,    12,    13,    55,
    15,    41,    42,    43,    44,    45,   196,    55,    41,    42,
    43,    44,    45,    28,    29,    30,    31,    32,    52,    34,
    35,    36,    37,    56,    39,    55,    41,    42,    55,    55,
    55,    46,    47,    55,    55,    55,    55,    52,    55,    57,
    55,     3,     4,     5,     6,     7,     8,     9,    10,    11,
    12,    13,    56,    15,    56,    56,    41,    42,    43,    44,
    45,    41,    42,    43,    44,    45,    28,    29,    30,    31,
    32,    56,    34,    35,    36,    37,    56,    39,    56,    41,
    42,    56,    47,    57,    46,    47,    57,    45,    47,    57,
    52,    57,    56,    55,    41,    42,    43,    44,    45,    41,
    42,    43,    44,    45,    41,    42,    43,    44,    45,    56,
     0,    57,    57,    57,    56,    56,    56,    47,    57,    56,
    41,    42,    43,    44,    45,    41,    42,    43,    44,    45,
    41,    42,    43,    44,    45,    56,    56,    47,    57,    57,
    56,    56,    56,    56,    56,    56,    41,    42,    43,    44,
    45,    56,    56,     0,    57,    57,    56,    56,     6,    -1,
    -1,    56,    -1,    99
};

#line 352 "/usr/share/bison++/bison.cc"
 /* fattrs + tables */

/* parser code folow  */


/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: dollar marks section change
   the next  is replaced by the list of actions, each action
   as one case of the switch.  */ 

#if YY_parse_USE_GOTO != 0
/* 
 SUPRESSION OF GOTO : on some C++ compiler (sun c++)
  the goto is strictly forbidden if any constructor/destructor
  is used in the whole function (very stupid isn't it ?)
 so goto are to be replaced with a 'while/switch/case construct'
 here are the macro to keep some apparent compatibility
*/
#define YYGOTO(lb) {yy_gotostate=lb;continue;}
#define YYBEGINGOTO  enum yy_labels yy_gotostate=yygotostart; \
                     for(;;) switch(yy_gotostate) { case yygotostart: {
#define YYLABEL(lb) } case lb: {
#define YYENDGOTO } } 
#define YYBEGINDECLARELABEL enum yy_labels {yygotostart
#define YYDECLARELABEL(lb) ,lb
#define YYENDDECLARELABEL  };
#else
/* macro to keep goto */
#define YYGOTO(lb) goto lb
#define YYBEGINGOTO 
#define YYLABEL(lb) lb:
#define YYENDGOTO
#define YYBEGINDECLARELABEL 
#define YYDECLARELABEL(lb)
#define YYENDDECLARELABEL 
#endif
/* LABEL DECLARATION */
YYBEGINDECLARELABEL
  YYDECLARELABEL(yynewstate)
  YYDECLARELABEL(yybackup)
/* YYDECLARELABEL(yyresume) */
  YYDECLARELABEL(yydefault)
  YYDECLARELABEL(yyreduce)
  YYDECLARELABEL(yyerrlab)   /* here on detecting error */
  YYDECLARELABEL(yyerrlab1)   /* here on error raised explicitly by an action */
  YYDECLARELABEL(yyerrdefault)  /* current state does not do anything special for the error token. */
  YYDECLARELABEL(yyerrpop)   /* pop the current state because it cannot handle the error token */
  YYDECLARELABEL(yyerrhandle)  
YYENDDECLARELABEL
/* ALLOCA SIMULATION */
/* __HAVE_NO_ALLOCA */
#ifdef __HAVE_NO_ALLOCA
int __alloca_free_ptr(char *ptr,char *ref)
{if(ptr!=ref) free(ptr);
 return 0;}

#define __ALLOCA_alloca(size) malloc(size)
#define __ALLOCA_free(ptr,ref) __alloca_free_ptr((char *)ptr,(char *)ref)

#ifdef YY_parse_LSP_NEEDED
#define __ALLOCA_return(num) \
            do { return( __ALLOCA_free(yyss,yyssa)+\
		    __ALLOCA_free(yyvs,yyvsa)+\
		    __ALLOCA_free(yyls,yylsa)+\
		   (num)); } while(0)
#else
#define __ALLOCA_return(num) \
            do { return( __ALLOCA_free(yyss,yyssa)+\
		    __ALLOCA_free(yyvs,yyvsa)+\
		   (num)); } while(0)
#endif
#else
#define __ALLOCA_return(num) do { return(num); } while(0)
#define __ALLOCA_alloca(size) alloca(size)
#define __ALLOCA_free(ptr,ref) 
#endif

/* ENDALLOCA SIMULATION */

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (YY_parse_CHAR = YYEMPTY)
#define YYEMPTY         -2
#define YYEOF           0
#define YYACCEPT        __ALLOCA_return(0)
#define YYABORT         __ALLOCA_return(1)
#define YYERROR         YYGOTO(yyerrlab1)
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL          YYGOTO(yyerrlab)
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do                                                              \
  if (YY_parse_CHAR == YYEMPTY && yylen == 1)                               \
    { YY_parse_CHAR = (token), YY_parse_LVAL = (value);                 \
      yychar1 = YYTRANSLATE (YY_parse_CHAR);                                \
      YYPOPSTACK;                                               \
      YYGOTO(yybackup);                                            \
    }                                                           \
  else                                                          \
    { YY_parse_ERROR ("syntax error: cannot back up"); YYERROR; }   \
while (0)

#define YYTERROR        1
#define YYERRCODE       256

#ifndef YY_parse_PURE
/* UNPURE */
#define YYLEX           YY_parse_LEX()
#ifndef YY_USE_CLASS
/* If nonreentrant, and not class , generate the variables here */
int     YY_parse_CHAR;                      /*  the lookahead symbol        */
YY_parse_STYPE      YY_parse_LVAL;              /*  the semantic value of the */
				/*  lookahead symbol    */
int YY_parse_NERRS;                 /*  number of parse errors so far */
#ifdef YY_parse_LSP_NEEDED
YY_parse_LTYPE YY_parse_LLOC;   /*  location data for the lookahead     */
			/*  symbol                              */
#endif
#endif


#else
/* PURE */
#ifdef YY_parse_LSP_NEEDED
#define YYLEX           YY_parse_LEX(&YY_parse_LVAL, &YY_parse_LLOC)
#else
#define YYLEX           YY_parse_LEX(&YY_parse_LVAL)
#endif
#endif
#ifndef YY_USE_CLASS
#if YY_parse_DEBUG != 0
int YY_parse_DEBUG_FLAG;                    /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif
#endif



/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif


#if __GNUC__ > 1                /* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM,TO,COUNT)       __builtin_memcpy(TO,FROM,COUNT)
#else                           /* not GNU C or C++ */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */

#ifdef __cplusplus
static void __yy_bcopy (char *from, char *to, int count)
#else
#ifdef __STDC__
static void __yy_bcopy (char *from, char *to, int count)
#else
static void __yy_bcopy (from, to, count)
     char *from;
     char *to;
     int count;
#endif
#endif
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}
#endif


int
#ifdef YY_USE_CLASS
 YY_parse_CLASS::
#endif
     YY_parse_PARSE(YY_parse_PARSE_PARAM)
#ifndef __STDC__
#ifndef __cplusplus
#ifndef YY_USE_CLASS
/* parameter definition without protypes */
YY_parse_PARSE_PARAM_DEF
#endif
#endif
#endif
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YY_parse_STYPE *yyvsp;
  int yyerrstatus;      /*  number of tokens to shift before error messages enabled */
  int yychar1=0;          /*  lookahead token as an internal (translated) token number */

  short yyssa[YYINITDEPTH];     /*  the state stack                     */
  YY_parse_STYPE yyvsa[YYINITDEPTH];        /*  the semantic value stack            */

  short *yyss = yyssa;          /*  refer to the stacks thru separate pointers */
  YY_parse_STYPE *yyvs = yyvsa;     /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YY_parse_LSP_NEEDED
  YY_parse_LTYPE yylsa[YYINITDEPTH];        /*  the location stack                  */
  YY_parse_LTYPE *yyls = yylsa;
  YY_parse_LTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YY_parse_PURE
  int YY_parse_CHAR;
  YY_parse_STYPE YY_parse_LVAL;
  int YY_parse_NERRS;
#ifdef YY_parse_LSP_NEEDED
  YY_parse_LTYPE YY_parse_LLOC;
#endif
#endif

  YY_parse_STYPE yyval;             /*  the variable used to return         */
				/*  semantic values from the action     */
				/*  routines                            */

  int yylen;
/* start loop, in which YYGOTO may be used. */
YYBEGINGOTO

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Starting parse\n");
#endif
  yystate = 0;
  yyerrstatus = 0;
  YY_parse_NERRS = 0;
  YY_parse_CHAR = YYEMPTY;          /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YY_parse_LSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
YYLABEL(yynewstate)

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YY_parse_STYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YY_parse_LSP_NEEDED
      YY_parse_LTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YY_parse_LSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YY_parse_LSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  YY_parse_ERROR("parser stack overflow");
	  __ALLOCA_return(2);
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) __ALLOCA_alloca (yystacksize * sizeof (*yyssp));
      __yy_bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      __ALLOCA_free(yyss1,yyssa);
      yyvs = (YY_parse_STYPE *) __ALLOCA_alloca (yystacksize * sizeof (*yyvsp));
      __yy_bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
      __ALLOCA_free(yyvs1,yyvsa);
#ifdef YY_parse_LSP_NEEDED
      yyls = (YY_parse_LTYPE *) __ALLOCA_alloca (yystacksize * sizeof (*yylsp));
      __yy_bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
      __ALLOCA_free(yyls1,yylsa);
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YY_parse_LSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  YYGOTO(yybackup);
YYLABEL(yybackup)

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* YYLABEL(yyresume) */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    YYGOTO(yydefault);

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (YY_parse_CHAR == YYEMPTY)
    {
#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Reading a token: ");
#endif
      YY_parse_CHAR = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (YY_parse_CHAR <= 0)           /* This means end of input. */
    {
      yychar1 = 0;
      YY_parse_CHAR = YYEOF;                /* Don't call YYLEX any more */

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(YY_parse_CHAR);

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	{
	  fprintf (stderr, "Next token is %d (%s", YY_parse_CHAR, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, YY_parse_CHAR, YY_parse_LVAL);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    YYGOTO(yydefault);

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	YYGOTO(yyerrlab);
      yyn = -yyn;
      YYGOTO(yyreduce);
    }
  else if (yyn == 0)
    YYGOTO(yyerrlab);

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Shifting token %d (%s), ", YY_parse_CHAR, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (YY_parse_CHAR != YYEOF)
    YY_parse_CHAR = YYEMPTY;

  *++yyvsp = YY_parse_LVAL;
#ifdef YY_parse_LSP_NEEDED
  *++yylsp = YY_parse_LLOC;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  YYGOTO(yynewstate);

/* Do the default action for the current state.  */
YYLABEL(yydefault)

  yyn = yydefact[yystate];
  if (yyn == 0)
    YYGOTO(yyerrlab);

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
YYLABEL(yyreduce)
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


 #line 839 "/usr/share/bison++/bison.cc"

  switch (yyn) {

case 2:
#line 112 "cel.ypp"
{ 
		
		std::cout << "[corpus]: Rule 'corpus' read " << endl;
		
		;
    break;}
case 4:
#line 121 "cel.ypp"
{
		std::cout << "[list_of_includes]: Rule 'list_of_includes' read" << endl;
	;
    break;}
case 5:
#line 125 "cel.ypp"
{
		std::cout << "[include_declaration]: 'include_declaration' read " << endl;
	;
    break;}
case 6:
#line 131 "cel.ypp"
{		
		std::cout << "[include] : " << std::endl;
		std::cout << "Switching to buffer " << yyvsp[-1].stringType << endl;
		std::cout << "Saving line " << yylineno << endl;
		CEL::CelParser::getSingletonParser()->m_flexInputBuffers.setLineNo(yylineno);
		yylineno = 1;
		CEL::CelParser::getSingletonParser()->m_flexInputBuffers.addBuffer(yyvsp[-1].stringType);		
		CEL::CelParser::getSingletonParser()->m_flexInputBuffers.createAndSwitchBuffer();
						
	;
    break;}
case 7:
#line 143 "cel.ypp"
{
		std::cout << "[eof]: " << std::endl;
		std::cout << " Buffer size is "
			<< CEL::CelParser::getSingletonParser()->m_flexInputBuffers.bufferSize() << endl;
		if (CEL::CelParser::getSingletonParser()->m_flexInputBuffers.bufferSize() <= 1) {
			
		} else {
			std::cout << "One more up " << endl;
			yy_delete_buffer(CEL::CelParser::getSingletonParser()->m_flexInputBuffers.getBuffer());
			CEL::CelParser::getSingletonParser()->m_flexInputBuffers.retrieveBuffer();
			yylineno = CEL::CelParser::getSingletonParser()->m_flexInputBuffers.getLineNo();
			std::cout << "Back to Buffer " 
				<< CEL::CelParser::getSingletonParser()->m_flexInputBuffers.getFileName()
				<< "at line " << yylineno << endl;
			yy_switch_to_buffer(CEL::CelParser::getSingletonParser()->m_flexInputBuffers.getBuffer());
		}
	;
    break;}
case 10:
#line 165 "cel.ypp"
{
			std::cout << "[declaration]:" << std::endl;
			if (CEL::CelParser::getSingletonParser()->existsSymbol(*yyvsp[-3].symbolType) ) {
				yyerror(" Symbole already defined ");
			} else {
				std::cout << " we store symbol " << yyvsp[-3].symbolType->getSymbolName() << std::endl;
				yyvsp[-3].symbolType->setExpression(yyvsp[-1].expressionType);
				CEL::getSymbolTableSingleton().addSymbol(*yyvsp[-3].symbolType,yyvsp[-1].expressionType);				
				CEL::getSymbolTableSingleton().printSymbolTable();
				std::cout << "stored..." << std::endl;

				// ok we remove the local symboles and  pop the saved symbols and clear the savedSymbolTable
				CEL::getSymbolTableSingleton().removeSymbols(localSymbols);
				
				std::cout << "cleaning local symbol table" << std::endl;
				CEL::getSymbolTableSingleton().restoreSymbols(savedSymbols);
				savedSymbols.clear();

				
				CEL::getSymbolTableSingleton().printSymbolTable();


			}		
		;
    break;}
case 11:
#line 191 "cel.ypp"
{
			std::cout << "[leftBodyRelation]:" << std::endl;
			std::cout << "Creating a symbol" << yyvsp[0].stringType << std::endl;
			yyval.symbolType = new CEL::Symbol(yyvsp[0].stringType);
		;
    break;}
case 12:
#line 198 "cel.ypp"
{			
			std::cout << "[lefBodyRelation]:" << std::endl;
			yyval.symbolType = new CEL::Symbol(yyvsp[-3].stringType);
			CEL::HashTable::iterator it;
			localSymbols.clear();
			for (it = yyvsp[-1].hashTableType->begin(); it != yyvsp[-1].hashTableType->end(); it ++) {
				std::cout << "   adding parameter " <<  it->first.getSymbolName() << std::endl;
				yyval.symbolType->addParameter(it->first.getSymbolName());
				localSymbols.addSymbol(it->first, NULL);
			}
			// we add these local parameters on the symboltable (and save the similar ones if necessary)
			std::cout << " Adding local parameters in the symbolTable and saving older symbols... " << std::endl;
			savedSymbols = CEL::getSymbolTableSingleton().addSymbols( localSymbols );
			savedSymbols.printSymbolTable();
		;
    break;}
case 13:
#line 217 "cel.ypp"
{
			std::cout << "[list_of_leftArguments]:" << std::endl;
			yyval.hashTableType = new CEL::HashTable();
			if (yyval.hashTableType->find(CEL::Symbol(yyvsp[0].stringType)) != yyval.hashTableType->end()) {		
				yyerror(" Argument Symbole already defined ");
			} else {
				(*yyval.hashTableType)[CEL::Symbol(yyvsp[0].stringType)] = NULL;				
			}	
			
		 ;
    break;}
case 14:
#line 228 "cel.ypp"
{
			std::cout << "[list_of_leftArguments]:" << std::endl;
			yyval.hashTableType = yyvsp[-2].hashTableType;
			if (yyval.hashTableType->find(CEL::Symbol(yyvsp[0].stringType)) != yyval.hashTableType->end()) {		
				yyerror(" Argument Symbole already defined ");
			} else {
				(*yyval.hashTableType)[CEL::Symbol(yyvsp[0].stringType)] = NULL;				
			}
		
		 	yyval.hashTableType = yyvsp[-2].hashTableType;
		 ;
    break;}
case 15:
#line 242 "cel.ypp"
{ 
			std::cout << "[leftArgument]:" << std::endl;
			yyval.stringType = yyvsp[0].stringType;
		;
    break;}
case 16:
#line 249 "cel.ypp"
{
			std::cout << "[rightBodyRelation]:" << std::endl;
			yyval.expressionType = yyvsp[0].expressionType;
		;
    break;}
case 17:
#line 255 "cel.ypp"
{  yyval.doubleType = yyvsp[0].doubleType; ;
    break;}
case 18:
#line 257 "cel.ypp"
{ yyval.doubleType = -yyvsp[0].doubleType; ;
    break;}
case 19:
#line 259 "cel.ypp"
{ yyval.doubleType = yyvsp[0].doubleType; ;
    break;}
case 20:
#line 263 "cel.ypp"
{ 
			std::cout << "[expression]: DOUBLE" << std::endl;
			yyval.expressionType = new CEL::BaseType(yyvsp[0].doubleType);
		;
    break;}
case 21:
#line 268 "cel.ypp"
{ 
			std::cout << "[expression]: ( )" << std::endl;
			yyval.expressionType = yyvsp[-1].expressionType;
		;
    break;}
case 22:
#line 274 "cel.ypp"
{
			std::cout << "[expression]: SQRT ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_SQRT);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 23:
#line 281 "cel.ypp"
{
			std::cout << "[expression]: SQR ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_SQR);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 24:
#line 288 "cel.ypp"
{
			std::cout << "[expression]: SIN ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_SIN);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 25:
#line 295 "cel.ypp"
{
			std::cout << "[expression]: COS ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_COS);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 26:
#line 302 "cel.ypp"
{
			std::cout << "[expression]: TAN ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_TAN);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 27:
#line 309 "cel.ypp"
{
			std::cout << "[expression]: ASIN ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_ASIN);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 28:
#line 316 "cel.ypp"
{
			std::cout << "[expression]: ACOS ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_ACOS);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 29:
#line 323 "cel.ypp"
{
			std::cout << "[expression]: ATAN ( )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_ATAN);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 30:
#line 331 "cel.ypp"
{
			std::cout << "[expression]: ATAN2 (  exp , exp )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_ATAN2);
			op->push_back(yyvsp[-3].expressionType);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 31:
#line 340 "cel.ypp"
{
			std::cout << "[expression]: EXP (   )" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_EXP);
			op->push_back(yyvsp[-1].expressionType);
			yyval.expressionType = op;		
		;
    break;}
case 32:
#line 348 "cel.ypp"
{
			std::cout << "[expression]: COUNT (  )" << std::endl;
			yyval.expressionType = new CEL::CountPixelSetOperator(yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 33:
#line 354 "cel.ypp"
{
			std::cout << "[expression]: MAXX (  )" << std::endl;
			yyval.expressionType = new CEL::MaxXPixelSetOperator(yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 34:
#line 360 "cel.ypp"
{
			std::cout << "[expression]: MINX (  )" << std::endl;
			yyval.expressionType = new CEL::MinXPixelSetOperator(yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 35:
#line 367 "cel.ypp"
{
			std::cout << "[expression]: MAXY (  )" << std::endl;
			yyval.expressionType = new CEL::MaxYPixelSetOperator(yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 36:
#line 373 "cel.ypp"
{
			std::cout << "[expression]: MINY (  )" << std::endl;
			yyval.expressionType = new CEL::MinYPixelSetOperator(yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 37:
#line 379 "cel.ypp"
{
			std::cout << "[expression]: DISTANCE (  )" << std::endl;
			yyval.expressionType = new CEL::DistancePixelSetOperator(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 38:
#line 385 "cel.ypp"
{
			std::cout << "[expression]: RECT (  )" << std::endl;
			yyval.expressionType = new CEL::QuadFrame(yyvsp[-7].doubleType,yyvsp[-5].doubleType,yyvsp[-3].doubleType,yyvsp[-1].doubleType);
		;
    break;}
case 39:
#line 391 "cel.ypp"
{
			std::cout << "[expression]: VIEWVOLUME" << std::endl;
			yyval.expressionType = new CEL::ViewVolume();

		;
    break;}
case 40:
#line 398 "cel.ypp"
{			
			std::cout << "[expression]: UMINUS " << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_UNARY_MINUS);
			op->push_back(yyvsp[0].expressionType);
			yyval.expressionType = op;
		;
    break;}
case 41:
#line 406 "cel.ypp"
{  
			std::cout << "[expression]: exp - exp" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_MINUS);
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);			
			yyval.expressionType = op;
		;
    break;}
case 42:
#line 414 "cel.ypp"
{  
			std::cout << "[expression]: exp + exp" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_PLUS);
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);			
			yyval.expressionType = op;
		;
    break;}
case 43:
#line 422 "cel.ypp"
{  
			std::cout << "[expression]: exp * exp" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_MULTIPLICATION);
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);			
			yyval.expressionType = op;
		;
    break;}
case 44:
#line 430 "cel.ypp"
{  
			std::cout << "[expression]: exp / exp" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_DIVISION);
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);			
			yyval.expressionType = op;
		;
    break;}
case 45:
#line 438 "cel.ypp"
{  
			std::cout << "[expression]: exp ^ exp" << std::endl;
			CEL::Operator *op = new CEL::MathOperator(CEL::MathOperator::MATH_POWER);
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);			
			yyval.expressionType = op;
		;
    break;}
case 46:
#line 446 "cel.ypp"
{
			std::cout << "[expression]: imageWidth" << std::endl;
			CEL::Operator *op = new CEL::Constant(CEL::Constant::IMAGE_WIDTH);
			yyval.expressionType = op;
		;
    break;}
case 47:
#line 453 "cel.ypp"
{
			std::cout << "[expression]: imageHeight" << std::endl;
			CEL::Operator *op = new CEL::Constant(CEL::Constant::IMAGE_HEIGHT);
			yyval.expressionType = op;
		;
    break;}
case 48:
#line 460 "cel.ypp"
{
			std::cout << "[expression]: targetExpression" << std::endl;
			yyval.expressionType = yyvsp[0].targetExpressionType;
		;
    break;}
case 49:
#line 466 "cel.ypp"
{
			std::cout << "[expression]: functionCall " << std::endl;
			if (CEL::CelParser::getSingletonParser()->existsSymbol(yyvsp[0].callFunctionType->getFunctionName())) {
				
				yyval.expressionType = yyvsp[0].callFunctionType;
								
			} else {
				yyerror("Unknown function call!");	
			}
		;
    break;}
case 50:
#line 477 "cel.ypp"
{
			std::cout << "[expression]: if then else " << std::endl;
			CEL::Operator *op = new CEL::ConditionalOperator();
			op->push_back(yyvsp[-4].expressionType);
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);
			yyval.expressionType = op;
		;
    break;}
case 51:
#line 487 "cel.ypp"
{
			// no secure test, $2 needs to be one of the the following...
			std::cout << " reading Comparator " << yyvsp[-1].stringType << std::endl;
			CEL::Operator *op;			
			if (std::string(yyvsp[-1].stringType) == std::string("==")) op  = new CEL::ComparisonOperator(CEL::ComparisonOperator::EQ);
			if (std::string(yyvsp[-1].stringType) == std::string(">=")) op  = new CEL::ComparisonOperator(CEL::ComparisonOperator::GEQ);
			if (std::string(yyvsp[-1].stringType) == std::string(">"))  op  = new CEL::ComparisonOperator(CEL::ComparisonOperator::GREATER);
			if (std::string(yyvsp[-1].stringType) == std::string("<=")) op  = new CEL::ComparisonOperator(CEL::ComparisonOperator::LEQ);
			if (std::string(yyvsp[-1].stringType) == std::string("<"))  op  = new CEL::ComparisonOperator(CEL::ComparisonOperator::LOWER);
			if (std::string(yyvsp[-1].stringType) == std::string("!=")) op  = new CEL::ComparisonOperator(CEL::ComparisonOperator::DIFFERENT);
			
			op->push_back(yyvsp[-2].expressionType);
			op->push_back(yyvsp[0].expressionType);
			
			yyval.expressionType = op;
		;
    break;}
case 52:
#line 505 "cel.ypp"
{
			std::cout << "[pixelSetExpression]: CUBERENDER ( ) " << std::endl;
			
			yyval.pixelSetExpressionType = new CEL::CubeRendererPixelSetExpression(yyvsp[-1].targetExpressionType);

		;
    break;}
case 53:
#line 512 "cel.ypp"
{
			std::cout << "[pixelSetExpression]: RENDER ( ) " << std::endl;
			
			yyval.pixelSetExpressionType = new CEL::RendererPixelSetExpression(yyvsp[-1].targetExpressionType);
		;
    break;}
case 54:
#line 518 "cel.ypp"
{
			std::cout << "[pixelSetExpression]: SILHOUETTE ( ) " << std::endl;
			yyval.pixelSetExpressionType = new CEL::SilhouettePixelSetExpression(yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 55:
#line 523 "cel.ypp"
{
			std::cout << "[expression]: COVEREDBY (  )" << std::endl;
			yyval.pixelSetExpressionType = new CEL::CoveredByPixelSetExpression(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 56:
#line 529 "cel.ypp"
{
			std::cout << "[expression]: LEFTOF (  )" << std::endl;
			yyval.pixelSetExpressionType = new CEL::LeftOfPixelSetExpression(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 57:
#line 535 "cel.ypp"
{
			std::cout << "[expression]: RIGHTOF (  )" << std::endl;
			yyval.pixelSetExpressionType = new CEL::RightOfPixelSetExpression(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 58:
#line 541 "cel.ypp"
{
			std::cout << "[expression]: ABOVEOF (  )" << std::endl;
			yyval.pixelSetExpressionType = new CEL::AboveOfPixelSetExpression(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 59:
#line 547 "cel.ypp"
{
			std::cout << "[expression]: BELOWOF (  )" << std::endl;
			yyval.pixelSetExpressionType = new CEL::BelowOfPixelSetExpression(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 60:
#line 553 "cel.ypp"
{
			std::cout << "[expression]: OVERLAP (  )" << std::endl;
			yyval.pixelSetExpressionType = new CEL::OverlapPixelSetExpression(yyvsp[-3].pixelSetExpressionType,yyvsp[-1].pixelSetExpressionType);
		;
    break;}
case 61:
#line 560 "cel.ypp"
{
			std::cout << "[TargetExpression]: target " << std::endl;
			yyval.targetExpressionType = yyvsp[0].targetType;
		;
    break;}
case 62:
#line 564 "cel.ypp"
{
			std::cout << "[TargetExpression]: ! targets " << std::endl;
			yyval.targetExpressionType = new CEL::TargetNegation(yyvsp[0].targetExpressionType);
		;
    break;}
case 63:
#line 570 "cel.ypp"
{
			std::cout << "[Targets]: target " << std::endl;
			yyval.targetExpressionType = yyvsp[0].targetType;
		;
    break;}
case 64:
#line 575 "cel.ypp"
{
			std::cout << "[Targets]: [ list of targets ] " << std::endl;
			yyval.targetExpressionType = yyvsp[-1].vectorOfTargetsType;
		;
    break;}
case 65:
#line 581 "cel.ypp"
{
			std::cout << "[target]: \" targetname\"  " << std::endl;
			yyval.targetType = new CEL::Target(yyvsp[-1].stringType);
		;
    break;}
case 66:
#line 587 "cel.ypp"
{
			std::cout << "[target]: RECT (  )" << std::endl;
			yyval.targetType = new CEL::QuadFrame(yyvsp[-7].doubleType,yyvsp[-5].doubleType,yyvsp[-3].doubleType,yyvsp[-1].doubleType);
		;
    break;}
case 67:
#line 592 "cel.ypp"
{
			std::cout << "[target]: VIEWVOLUME" << std::endl;
			yyval.targetType = new CEL::ViewVolume();

		;
    break;}
case 68:
#line 598 "cel.ypp"
{
			std::cout << "[functionCall] (TargetFunction)" << std::endl;
			yyval.targetType = new CEL::Target(yyvsp[0].callFunctionType);
		;
    break;}
case 69:
#line 604 "cel.ypp"
{	
			std::cout << "[ListOfTargets]: target  " << std::endl;
			yyval.vectorOfTargetsType = new CEL::VectorOfTargets();
			yyval.vectorOfTargetsType->push_back(yyvsp[0].targetType);
		;
    break;}
case 70:
#line 611 "cel.ypp"
{
			std::cout << "[ListOfTargets]: ListOfTargets , target  " << std::endl;
			yyvsp[-2].vectorOfTargetsType->push_back(yyvsp[0].targetType);
			yyval.vectorOfTargetsType = yyvsp[-2].vectorOfTargetsType;
		;
    break;}
case 72:
#line 620 "cel.ypp"
{
			std::cout << "[functionCall]: functionName  " << yyvsp[0].stringType << std::endl;
			yyval.callFunctionType = new CEL::CallFunctionOperator(yyvsp[0].stringType);
		
		;
    break;}
case 73:
#line 626 "cel.ypp"
{
			std::cout << "[functionCall]: functionName ( arguments )  " << yyvsp[-3].stringType << std::endl;
			// check the # of arguments is appropriate...
			if (yyvsp[-1].vectorExpressionType->size() != (CEL::CelParser::getSingletonParser()->getSymbol(yyvsp[-3].stringType)).getParameters().size()) {
				yyerror(" Wrong number of arguments ");
			} else {
			
				std::cout << "  number of args is correct" << std::endl;
				yyval.callFunctionType = new CEL::CallFunctionOperator(yyvsp[-3].stringType);
				
				// assign the parameter names to the expressions
				std::vector<CEL::Expression *>::iterator itExp;
				CEL::Parameters::const_iterator itName = CEL::CelParser::getSingletonParser()->getSymbol(yyvsp[-3].stringType).getParameters().begin();
				
				std::cout << "   size of parameterlist " << CEL::CelParser::getSingletonParser()->getSymbol(yyvsp[-3].stringType).getParameters().size() << std::endl;
				
				for (itExp = yyvsp[-1].vectorExpressionType->begin(); itExp != yyvsp[-1].vectorExpressionType->end(); ++itExp) {
					std::cout << "  assign the arg " << *itName << std::endl;
					yyval.callFunctionType->assignParameterInLocalSymbolTable( (*itName) , *itExp);
					++itName;
				}
				std::cout << "  args assigned" << std::endl;
			}
			// dont need the vector of expressions any more...
			delete yyvsp[-1].vectorExpressionType;
		;
    break;}
case 74:
#line 655 "cel.ypp"
{
			std::cout << "[functionName]: FUNCTION " << std::endl;

			CEL::getSymbolTableSingleton().printSymbolTable();
			// check if the symbol is ok...
			if (CEL::CelParser::getSingletonParser()->existsSymbol(CEL::Symbol(yyvsp[0].stringType))) {
				  
			  	yyval.stringType = yyvsp[0].stringType;
			
			} else {
				yyerror(" Unknown symbole");
			}
			
		;
    break;}
case 75:
#line 671 "cel.ypp"
{
			std::cout << "[list_of_rightArguments]: expression  " << std::endl;
			yyval.vectorExpressionType = new std::vector<CEL::Expression *>();
			yyval.vectorExpressionType->push_back(yyvsp[0].expressionType);		 
		;
    break;}
case 76:
#line 677 "cel.ypp"
{
			std::cout << "[list_of_rightArguments]: list_of_rightArguments , expression  " << std::endl;
			yyvsp[-2].vectorExpressionType->push_back(yyvsp[0].expressionType);
			yyval.vectorExpressionType = yyvsp[-2].vectorExpressionType;
		;
    break;}
case 77:
#line 685 "cel.ypp"
{
		;
    break;}
case 78:
#line 688 "cel.ypp"
{
		;
    break;}
case 79:
#line 693 "cel.ypp"
{
			std::cout << "[evaluator]:  expression  " << std::endl;
			CEL::CelParser::getSingletonParser()->addEvaluator(yyvsp[-1].expressionType);
		;
    break;}
}

#line 839 "/usr/share/bison++/bison.cc"
   /* the action file gets copied in in place of this dollarsign  */
  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YY_parse_LSP_NEEDED
  yylsp -= yylen;
#endif

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YY_parse_LSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = YY_parse_LLOC.first_line;
      yylsp->first_column = YY_parse_LLOC.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  YYGOTO(yynewstate);

YYLABEL(yyerrlab)   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++YY_parse_NERRS;

#ifdef YY_parse_ERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      YY_parse_ERROR(msg);
	      free(msg);
	    }
	  else
	    YY_parse_ERROR ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YY_parse_ERROR_VERBOSE */
	YY_parse_ERROR("parse error");
    }

  YYGOTO(yyerrlab1);
YYLABEL(yyerrlab1)   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (YY_parse_CHAR == YYEOF)
	YYABORT;

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Discarding token %d (%s).\n", YY_parse_CHAR, yytname[yychar1]);
#endif

      YY_parse_CHAR = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;              /* Each real token shifted decrements this */

  YYGOTO(yyerrhandle);

YYLABEL(yyerrdefault)  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) YYGOTO(yydefault);
#endif

YYLABEL(yyerrpop)   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YY_parse_LSP_NEEDED
  yylsp--;
#endif

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

YYLABEL(yyerrhandle)

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    YYGOTO(yyerrdefault);

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    YYGOTO(yyerrdefault);

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	YYGOTO(yyerrpop);
      yyn = -yyn;
      YYGOTO(yyreduce);
    }
  else if (yyn == 0)
    YYGOTO(yyerrpop);

  if (yyn == YYFINAL)
    YYACCEPT;

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = YY_parse_LVAL;
#ifdef YY_parse_LSP_NEEDED
  *++yylsp = YY_parse_LLOC;
#endif

  yystate = yyn;
  YYGOTO(yynewstate);
/* end loop, in which YYGOTO may be used. */
  YYENDGOTO
}

/* END */

 #line 1038 "/usr/share/bison++/bison.cc"
#line 699 "cel.ypp"




